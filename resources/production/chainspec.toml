[genesis]
# Human readable name for convenience; the genesis_hash is the true identifier.  The name influences the genesis hash by
# contributing to the seeding of the pseudo-random number generator used in contract-runtime for computing genesis
# post-state hash.
name = 'casper-charlie-testnet'
# Timestamp for the genesis block, also used in seeding the pseudo-random number generator used in contract-runtime for
# computing genesis post-state hash.
timestamp = 0
# Protocol version at genesis.
protocol_version = '1.0.0'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the mint
# system contract.
mint_installer_path = 'mint_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the Proof of
# Stake system contract.
pos_installer_path = 'pos_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the Standard
# Payment system contract.
standard_payment_installer_path = 'standard_payment_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the file containing wasm bytecode for installing the Auction
# system contract.
auction_installer_path = 'auction_install.wasm'
# Path (absolute, or relative to this chainspec.toml) to the CSV file containing initial account balances and bonds.
accounts_path = 'accounts.csv'

[highway]
# Tick unit is milliseconds.
#
# Unix timestamp for the genesis era.  At least one node has to be started when the genesis era is active in order to
# make key blocks for the upcoming eras.  If the era is over by the time we start the nodes, they'll not be able to
# produce blocks in it, and there won't be a new era build either.  That means when a completely new network is started,
# the genesis era start time has to be adjusted to be active at the time.
genesis_era_start_timestamp = 0
# Era duration defined as a fixed number of milliseconds. 1800000 ms = 30 minutes
era_duration_millis = 1800000
# Minimum number of blocks per era.  An era will take longer than `era_duration_millis` ms if that is necessary to reach the minimum height.
minimum_era_height = 10
# Amount of time in milliseconds to go back before the start of the era for picking the booking block.
booking_duration_millis = 0
# Amount of time in milliseconds to wait after the booking before we pick the key block, collecting the magic bits along
# the way.
entropy_duration_millis = 0
# Keep voting on the switch block for a fixed amount of time; effective if the summit level is zero.
voting_period_duration_millis = 0
# Integer between 0 and 99 representing the fault tolerance threshold as a percentage, used by the internal finalizer.
finality_threshold_percent = 33
# Integer between 0 and 255. The power of two that is the number of milliseconds in the minimum round length, and
# therefore the minimum delay between a block and its child. E.g. 14 means 2^14 milliseconds, i.e. about 16 seconds.
minimum_round_exponent = 17

[deploys]
# The maximum number of Motes allowed to be spent during payment.  0 means unlimited.
max_payment_cost = '0'
# The maximum number of milliseconds after the deploy timestamp that it can be included in a block.
# 86_400_000 ms = 1 day.
max_ttl_millis = 86_400_000
# The maximum number of other deploys a deploy can depend on (require to have been executed before it can execute).
max_dependencies = 10
# Maximum block size in bytes.  0 means unlimited.
max_block_size = 10_485_760
# The upper limit of total gas of all deploys in a block.
block_gas_limit = 10_000_000_000_000

[storage]
# Gas charged per byte stored in the global state.
gas_per_byte = 630_000_000

[wasm_costs]
# Default opcode cost.
regular = 210_000
# Div operations multiplier. (A div should cost 320_000)
div = 2
# Mul operations multiplier. (A mul should cost 240_000)
mul = 2
# Memory (load/store) operations multiplier. (A mem should cost 4_700_000)
mem = 23
# Amount of free memory (in 64kB pages) each contract can use for stack.
initial_mem = 4096
# Grow memory cost, per page (64kB).
grow_mem = 240_000_000
# Memory copy cost, per byte.
memcpy = 420_000
# Max stack height (native WebAssembly stack limiter).
max_stack_height = 65_536
# Cost of wasm opcode is calculated as TABLE_ENTRY_COST * `opcodes_mul` / `opcodes_div`.
opcodes_mul = 1
opcodes_div = 1

# Host function declarations are located in smart_contracts/contract/src/ext_ffi.rs
[host_function_costs]

add = 5_800_000
add_associated_key = 9_000_000
add_contract_version = 200_000_000 # Not instrumented yet, assuming a sufficiently large number
add_local = [810, 4_700_000]
call_contract = [420, 4_500_000]
call_versioned_contract = [420, 4_500_000] # Not instrumented yet, assuming the same as call_contract
create_content_package_at_hash = 200_000_000 # Not instrumented yet, assuming a sufficiently large number
create_contract_user_group = 200_000_000 # Not instrumented yet, assuming a sufficiently large number
create_purse = 170_000_000
disable_contract_version = 200_000_000 # Not instrumented yet, assuming a sufficiently large number
get_balance = 3_800_000
get_blocktime = 330_000
get_caller = 380_000
get_key = [440, 2_000_000]
get_main_purse = 1_300_000
get_named_arg = [76, 2_500_000]
get_named_arg_size = 450_000
get_phase = 710_000
get_system_contract = 1_100_000
has_key = [840, 1_500_000]
is_valid_uref = 760_000
load_named_keys = 42_000_000
new_uref = [590, 17_000_000]
provision_contract_user_group_uref = 200_000_000 # Not instrumented yet, assuming a sufficiently large number
put_key = [1_100, 38_000_000]
read_host_buffer = [310, 3_500_000]
read_value = 6_000_000
read_value_local = [590, 5_500_000]
remove_associated_key = 4_200_000
remove_contract_user_group = 200_000_000 # Not instrumented yet, assuming a sufficiently large number
remove_contract_user_group_urefs = 200_000_000 # Not instrumented yet, assuming a sufficiently large number
remove_key = [3_200, 61_000_000]
ret = [420_000, 260, 23_000_000]
revert = [500_000]
set_action_threshold = [74_000_000]
transfer_from_purse_to_account = [160_000_000]
transfer_from_purse_to_purse = [82_000_000]
transfer_to_account = [24_000_000]
update_associated_key = [4_200_000]
write = [980, 14_000_000]
write_local = [1_800, 520, 9_500_000]
